{
  "hash": "1b5c6fe97236e3930e798956a7459d67",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Explorations in functional programming in R\"\ndescription: \"Writing a complex function with unlimited arguments and masked variables.\"\nauthor:\n  - name: David Schoeman\ndate: 2024-10-10\ncategories: [R programming] # self-defined categories\nimage: mask.png\ndraft: false # setting this to `true` will prevent your post from appearing on your listing page until you're ready!\n---\n\n\n\n## The background\n\nWhen students show the initiative to use `R` beyond just ANM203, I sometimes try to show them tips and tricks that will make their journey into programming a little easier. Often, this involves showing them how to build simple functions.\n\nIn this case, I thought I could build a simple function to compute Simpson's Diversity index in a simple `group_by()` — `summarise()` workflow. \n\nBoy, was I wrong.\n\nThe answer turns out to be tricky, but not *that* tricky.\n\n## Building the function\n\n### Reading the data\n\nThe input data were saved as an `.rds` file, so we will attach the `tidyverse`, then read in the data:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.1\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n```\n\n\n:::\n\n```{.r .cell-code}\ndat <- read_rds(\"/Users/davidschoeman/Downloads/data.rds\") # Of course, if your data were in a .csv, you'd read_csv()\nhead(dat)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 6\n  Transect_code Campus Common_Name           Scientific_Name  Observations Year \n  <fct>         <fct>  <fct>                 <fct>                   <dbl> <fct>\n1 SDL2          SD     Brown thornbill       Acanthiza pusil…            1 2024 \n2 MBR           MB     Buff rumped thornbill Acanthiza regul…            1 2022 \n3 MBR           MB     Eastern Spinebill     Acanthorhynchus…            1 2023 \n4 MBP1          MB     Eastern Spinebill     Acanthorhynchus…            1 2021 \n5 MBR           MB     Eastern Spinebill     Acanthorhynchus…            2 2021 \n6 MBR           MB     Eastern Spinebill     Acanthorhynchus…            4 2021 \n```\n\n\n:::\n:::\n\n\n\n### A workflow for computing Simpson's Index\n\nThe idea is to build a function to compute Simpson's index using `Specific_Name` to identify the species involved, and `Observations` to represent their abundances.\n\nBefore we explore this as a workflow, we need to know the formula for the Simpson Diversity Index, D:\n\n$$\nD = \\frac{\\Sigma_{i}n_{i}(n_{i}-1)}{N(N-1)},\n$$\n\nwhere $n_{i}$ is the abundance of species $i$ and $N$ is the sum of all species abundances ($\\Sigma_{i}n_{i}$).\n\nLet's say that we wanted to compute this index for the `SD` `Campus`. The workflow would look something like this:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nd <- dat %>% \n  filter(Campus == \"SD\") # Filter for SD \n\nnumerator <- d %>% # First compute the numerator\n  group_by(Scientific_Name) %>% # To be sure that there aren't duplicate lines per species\n  summarise(n = sum(Observations, na.rm = TRUE)) %>% \n  mutate(n_min_1 = n - 1, # Add a variable for n-1\n         prod = n * n_min_1) %>%  # The product of n and n-1\n  summarise(sum(prod, na.rm = TRUE)) %>%  # The numerator is the sum of the product of n and n-1\n  deframe() # Make the output a number rather than a tibble\n\ndenominator <- d %>% # Next, the denominator\n  summarise(n = sum(Observations, na.rm = TRUE)) %>% \n      mutate(n_min_1 = n - 1,\n             prod = n * n_min_1) %>% # The demoniator is the sum of the total number of observations and the total minus one\n  pull(prod) # Extract just the product as a number\n\nS <- numerator/denominator # Do the calculation\n\nprint(S) # OUtput the result\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.1796166\n```\n\n\n:::\n:::\n\n\n\nI was hoping to turn this into a function deployed with `summarise()`, but found that it isn't straightforward to \"feed\" grouped data into a function this complex.\n\nSo, instead, we need to build a function that does the grouping as well as the summarising.\n\n### Building the actual function\n\nThe first issue is that if we want to build a function that is going to group and summarise data, we need to allow that function to have arguments that are names of variables.\n\nAchieving this is somewhat trickier than it sounds because if you call variable name, `R` will invariably error out because that variable exists within a `tibble`/`data.frame` rather than being present in the environment.\n\nSo...we need to *pretend* that the variable name is *not* an object. We do this with a technique called \"data masking\", which essentially means that you hide the variable name inside two pairs of braces: `{{ var }}`, where `var` is the name of the variable.\n\nAnother issue is that *if* you want your function to be flexible *as well as* generic, it has to be able to take any number of arguments to specify grouping variables. This is done within the function call, by specifying open-ended arguments using the ellipsis: `...`\n\nNote that to make a function, all we do is throw braces — `{}` — around a workflow, give the function a name and specify its arguments:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n  get_simpson <- function(.data, spp, abund, ...) {\n    # .data: the short-hand for the data emerging from a tidyverse pipe (so no need to specify this argument when using the function... the dot means it is \"hidden\")\n    # spp: an argument for the variable containing the species identifiers\n    # abund: an argument for the name of the variable containing abundance by species\n    # ...: arguments for the names of the variables you want to group by\n    \n    numerator <- .data %>% # .data is the data passed by the pipe\n      group_by(..., {{ spp }}) %>% # Group by named grouping variables, then by species identifier\n      summarise(n = sum({{ abund }}, na.rm = TRUE)) %>% # {{ abund }} is the variable containing abundances\n        # Note that this step accounts for the possibility of repeat rows for a species for any combination of grouping variables\n        mutate(n_min_1 = n - 1, # Add a variable for n-1\n             prod = n * n_min_1) %>% # Add a variable for the product of n and n-1\n      group_by(...) %>% # Group the result by the grouping variables\n      summarise(numerator = sum(prod, na.rm = TRUE)) # Compute the sum of the products per group\n   \n    denominator <- .data %>%\n      group_by(...) %>% # We want the denominator only for groups, NOT for the species\n      summarise(n = sum({{ abund }}, na.rm = TRUE)) %>% # The overall sum per group\n      mutate(n_min_1 = n - 1, # n-1\n             denominator = n * n_min_1) %>% # n * n-1\n    select(-n, -n_min_1) # Remove unused rows\n    \n    out <- left_join(numerator, denominator) %>% # Combine the tibbles into a single tibble; R will use the grouping variables to ensure that values are in the correct rows\n      mutate(D = numerator/denominator) %>% # Do the calculation per row/group\n      select(-numerator, -denominator) # Remove unwanted variables\n    \n  return(out) # Return the answer\n  } \n```\n:::\n\n\n\nLet's give it a whirl, knowing that the Simpson Diversity index for `SD` is 0.18:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat %>% \n  get_simpson(Scientific_Name, Observations, Campus) # Spp ID, abundance, grouping variable\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n`summarise()` has grouped output by 'Campus'. You can override using the\n`.groups` argument.\nJoining with `by = join_by(Campus)`\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 × 2\n  Campus      D\n  <fct>   <dbl>\n1 MB     0.0757\n2 SD     0.180 \n```\n\n\n:::\n:::\n\n\n\nWorks! Or, at least, it gives the same answer as I got before.\n\nA more complex deployment, remembering that we can group by more than just campus:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat %>% \n  get_simpson(Scientific_Name, Observations, Campus, Year) # Grouping by campus and year\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n`summarise()` has grouped output by 'Campus', 'Year'. You can override using\nthe `.groups` argument.\n`summarise()` has grouped output by 'Campus'. You can override using the\n`.groups` argument.\n`summarise()` has grouped output by 'Campus'. You can override using the\n`.groups` argument.\nJoining with `by = join_by(Campus, Year)`\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 8 × 3\n# Groups:   Campus [2]\n  Campus Year       D\n  <fct>  <fct>  <dbl>\n1 MB     2021  0.0905\n2 MB     2022  0.0913\n3 MB     2023  0.0980\n4 MB     2024  0.0776\n5 SD     2021  0.132 \n6 SD     2022  0.361 \n7 SD     2023  0.0402\n8 SD     2024  0.0811\n```\n\n\n:::\n:::\n\n\n\nThis seems to give rational outputs, although I would check before deploying in a serious context.\n\n## Conclusion\n\nThis short blog is not about a diversity index, but rather about how easy it is to write and deploy fairly complex functions, allowing us to use variable names as unquoted arguments, and even to have an unlimited number of arguments in other contexts. Play around with these ideas...they have proven very helpful in my coding journey. I hope that they are equally useful to you.",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}